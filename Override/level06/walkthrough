Here the program takes first a username with a fgets.

   0x080488e7 <+110>:   call   0x8048550 <fgets@plt>

Then it take a serial which is a unsigned int with a scanf

  0x0804892d <+180>:   call   0x80485e0 <__isoc99_scanf@plt>


After it calls the auth function and give it both entry as parameters.
It will first check if the username is greater than 5 char. If not it exits.
Then there is a tampering detecting with ptrace.
I guess this here to prevent us to easily use GDB.
Then it is going to manipulate the username and do a sort of hash on it and get an value from it.
It will then compare the serial gave in entry with the hash.
If they are the same the func auth will return 0 then allow the main function to call the sys call to open a shell.

   0x0804895d <+228>:   call   0x80485a0 <system@plt>

So here what we're going to do is using GDB avoiding the tampering detection.
To do this will have to set good breakpoints and jump to avoid this part of the code.
What will do after is check the stack where the serial for a given username is stored.
Then start the program with the previous username and the serial found in the stack and it should work.

level06@OverRide:~$ gdb level06
(gdb) disas auth
[...]
   0x08048796 <+78>:    movl   $0x0,0xc(%esp)
   0x0804879e <+86>:    movl   $0x1,0x8(%esp)
   0x080487a6 <+94>:    movl   $0x0,0x4(%esp)
   0x080487ae <+102>:   movl   $0x0,(%esp)
   0x080487b5 <+109>:   call   0x80485f0 <ptrace@plt>
   0x080487ba <+114>:   cmp    $0xffffffff,%eax
   0x080487bd <+117>:   jne    0x80487ed <auth+165>  <==  We are going to set our first breakpoint here
   0x080487bf <+119>:   movl   $0x8048a68,(%esp)          just when the value of the cmp is checked
   0x080487c6 <+126>:   call   0x8048590 <puts@plt>       We are supposed to get caught here.
   0x080487cb <+131>:   movl   $0x8048a8c,(%esp)
   0x080487d2 <+138>:   call   0x8048590 <puts@plt>
   0x080487d7 <+143>:   movl   $0x8048ab0,(%esp)
   0x080487de <+150>:   call   0x8048590 <puts@plt>
   0x080487e3 <+155>:   mov    $0x1,%eax
   0x080487e8 <+160>:   jmp    0x8048877 <auth+303>
   0x080487ed <+165>:   mov    0x8(%ebp),%eax        <== We are going to jump here after first bp
                                                         just as if the ptrace would return the correct value
[...]

   0x08048863 <+283>:   mov    0xc(%ebp),%eax
   0x08048866 <+286>:   cmp    -0x10(%ebp),%eax      <== We set the second breakpoint here
   0x08048869 <+289>:   je     0x8048872 <auth+298>      just when the value of the serial is stored
                                                         to check what it is. (stored in $ebp-0x10)

(gdb) b *0x080487bd
Breakpoint 1 at 0x80487bd
(gdb) b *0x08048866
Breakpoint 2 at 0x8048866
(gdb) r
Starting program: /home/users/level06/level06
***********************************
*               level06           *
***********************************
-> Enter Login: DRIMO&JJAOUEN
***********************************
***** NEW ACCOUNT DETECTED ********
***********************************
-> Enter Serial: 0
(gdb) ju *0x080487ed
Continuing at 0x80487ed.

Breakpoint 2, 0x08048866 in auth ()
(gdb) x $ebp-0x10
0xffffd6a8:     0x005f30bf

And here is the serial for the previous username: 0x005f30bf in decimal it gives: 6238399
So let's run the program with this.

level06@OverRide:~$ ./level06
***********************************
*               level06           *
***********************************
-> Enter Login: DRIMO&JJAOUEN
***********************************
***** NEW ACCOUNT DETECTED ********
***********************************
-> Enter Serial: 6238399
Authenticated!
$ whoami
level07
$ cat /home/users/level07/.pass
GbcPDRgsFK77LNnnuh7QyFYA2942Gp8yKj9KrWD8
